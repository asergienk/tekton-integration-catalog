apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: deploy-fbc-operator
spec:
  description: |
    The deploy-fbc-operator pipeline automates the provisioning of a EaaS Hypershift cluster and the deployment of an operator from a given FBC (File-Based Catalog) fragment.
    It automates the process of retrieving an unreleased bundle from the FBC, selecting an appropriate OpenShift version and architecture for cluster provisioning,
    installing the operator, and gathering cluster artifacts.
  params:
    - description: |
        Spec section of an ApplicationSnapshot resource. Not all fields of the
        resource are required. A minimal example:
          {
            "components": [
              {
                "containerImage": "quay.io/example/repo:latest",
                "source": {
                  "git": {
                    "url": "https://github.com/org/repo",
                    "revision": "6c1cbf4193930582d998770411f81d5c70aea29b"
                  }
                }
              }
            ]
          }
      name: SNAPSHOT
      type: string
    - description: |
        An OLM package name present in the fragment or leave it empty so the step will determine the default package name. 
        * If there is only one 'olm.package', it's name is returned.
        * If multiple 'olm.package' entries contain unreleased bundles, user input is required; the PACKAGE_NAME parameter must be set by the user.
      name: PACKAGE_NAME
      default: ""
      type: string
    - description: |
        An OLM channel name or leave it empty so the step will determine the default channel name. 
        * The default channel name corresponds to the 'defaultChannel' entry of the selected package.
      name: CHANNEL_NAME
      default: ""
      type: string
    - description: |
        Name of the secret containing the oci-storage-dockerconfigjson key with registry credentials in .dockerconfigjson format, used for pushing artifacts to an OCI registry.
        Example:
          apiVersion: v1
          kind: Secret
          metadata:
            name: example
            namespace: sample-tenant
          type: Opaque
          data:
            oci-storage-dockerconfigjson: <BASE64_ENCODED_DOCKERCONFIGJSON>
      name: CREDENTIALS_SECRET_NAME
      type: string
    - description: Full OCI artifact reference in a format "quay.io/org/repo:tag"
      name: OCI_REF
      type: string
  tasks:
    - name: parse-metadata
      taskRef:
        resolver: git
        params:
          - name: url
            value: https://github.com/konflux-ci/integration-examples
          - name: revision
            value: main
          - name: pathInRepo
            value: tasks/test_metadata.yaml
      params:
        - name: SNAPSHOT
          value: $(params.SNAPSHOT)
    - name: provision-eaas-space
      runAfter:
        - parse-metadata
      taskRef:
        resolver: git
        params:
          - name: url
            value: https://github.com/konflux-ci/build-definitions.git
          - name: revision
            value: main
          - name: pathInRepo
            value: task/eaas-provision-space/0.1/eaas-provision-space.yaml
      params:
        - name: ownerName
          value: $(context.pipelineRun.name)
        - name: ownerUid
          value: $(context.pipelineRun.uid)
    - name: get-unreleased-bundle
      runAfter:
        - provision-eaas-space
      taskSpec:
        results:
          - name: unreleasedBundle
            description: "Unreleased bundle image (may be mirrored)"
          - name: packageName
            value: "$(steps.get-unreleased-bundle.results.packageName)"
          - name: channelName
            value: "$(steps.get-unreleased-bundle.results.channelName)"
        volumes:
          - name: git-repo
            emptyDir: {}
        steps:
          - name: get-unreleased-bundle
            computeResources:
              limits:
                memory: 4Gi
              requests:
                memory: 4Gi
                cpu: 500m
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/tekton-integration-catalog.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/bundles/get-unreleased-bundle/0.1/get-unreleased-bundle.yaml
            params:
              - name: fbcFragment
                value: "$(tasks.parse-metadata.results.component-container-image)"
              - name: packageName
                value: $(params.PACKAGE_NAME)
              - name: channelName
                value: $(params.CHANNEL_NAME)
          - name: process-image-mirror-set
            image: quay.io/konflux-ci/konflux-test:v1.4.21@sha256:ddce6bc954694b55808507c1f92dfe9d094d52c636c8154c3fee441faff19f90
            computeResources:
              limits:
                memory: 512Mi
              requests:
                memory: 512Mi
                cpu: 100m
            env:
              - name: BUNDLE_IMAGE
                value: "$(steps.get-unreleased-bundle.results.unreleasedBundle)"
              - name: SOURCE_GIT_URL
                value: "$(tasks.parse-metadata.results.source-git-url)"
              - name: SOURCE_GIT_REVISION
                value: "$(tasks.parse-metadata.results.source-git-revision)"
            script: |
              #!/usr/bin/env bash
              set -euo pipefail
              . /utils.sh

              replaced_image=""

              BUNDLE_IMAGE=registry.redhat.io/container-native-virtualization/hco-bundle-registry-rhel9@sha256:b299988d00d2f3211f294bc69e18556c2b3b0c822fc303f410301141f8056def

              # Check if the BUNDLE_IMAGE is empty or null
              if [[ -z "${BUNDLE_IMAGE}" || "${BUNDLE_IMAGE}" == "null" ]]; then
                echo "Unreleased bundle was not found. Cannot proceed with mirror substitution."
                echo -n "$replaced_image" > "$(results.unreleasedBundle.path)"
                exit 0
              fi
              
              # Check if the bundle image is pullable before anything else
              if skopeo inspect --no-tags --config "docker://${BUNDLE_IMAGE}" > /dev/null 2>&1; then
                echo "Bundle image $BUNDLE_IMAGE is pullable. Using as-is, without applying mirror substitution."
                echo -n "$BUNDLE_IMAGE" > "$(results.unreleasedBundle.path)"
                exit 0
              fi

              echo "Could not inspect original pullspec $BUNDLE_IMAGE. Checking if there's a mirror present"
              
              # Fetch and process mirror set
              mirror_set_url="${SOURCE_GIT_URL}/raw/${SOURCE_GIT_REVISION}/.tekton/images-mirror-set.yaml"
              
              # Fetch mirror map from the URL
              if mirror_set_yaml=$(curl -kfL "${mirror_set_url}"); then
                process_image_digest_mirror_set "${mirror_set_yaml}" > /tekton/home/mirror-map.txt
              else
                echo "Could not fetch image mirror set at ${mirror_set_url}. Unreleased bundles will fail opm render."
                exit 1
              fi

              # Check and apply mirror mapping
              if [ -s /tekton/home/mirror-map.txt ]; then
                echo "Image Mirror Map found:"
                cat /tekton/home/mirror-map.txt

                # Get registry and repo from BUNDLE_IMAGE
                reg_and_repo=$(get_image_registry_and_repository "${BUNDLE_IMAGE}")
                mapfile -t mirrors < <(jq -r --arg image "${reg_and_repo}" '.[$image][]' /tekton/home/mirror-map.txt)
                echo "Mirrors for $reg_and_repo are:"
                printf "%s\n" "${mirrors[@]}"

                # Iterate over mirrors and try each one
                for mirror in "${mirrors[@]}"; do
                  echo "Attempting to use mirror ${mirror}"
                  replaced_image=$(replace_image_pullspec "$BUNDLE_IMAGE" "$mirror")

                  # Check if the mirror is accessible
                  if ! bundle_out=$(skopeo inspect --no-tags --config "docker://${replaced_image}"); then
                    echo "Mirror $replaced_image is inaccessible."
                    continue
                  fi

                  echo "Replacing $BUNDLE_IMAGE with $replaced_image"
                  break
                done

                if [ -z "$replaced_image" ]; then
                  echo "No valid mirrors found for $BUNDLE_IMAGE"
                  exit 1
                fi
              else
                echo "Mirror map file is empty or not found."
                exit 1
              fi

              echo -n "$replaced_image" > "$(results.unreleasedBundle.path)"
    - name: pick-cluster-params
      runAfter:
        - get-unreleased-bundle
      when:
        - input: "$(tasks.get-unreleased-bundle.results.unreleasedBundle)"
          operator: notin
          values: [""]
      taskSpec:
        results:
          - name: ocpVersion
            value: "$(steps.pick-cluster-version.results.ocpVersion)"
          - name: bundleArch
            value: "$(steps.pick-cluster-arch.results.bundleArch)"
        steps:
          - name: get-supported-versions
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/build-definitions.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/eaas-get-supported-ephemeral-cluster-versions/0.1/eaas-get-supported-ephemeral-cluster-versions.yaml
            params:
              - name: eaasSpaceSecretRef
                value: "$(tasks.provision-eaas-space.results.secretRef)"
          - name: pick-cluster-version
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/asergienk/tekton-integration-catalog.git
                - name: revision
                  value: test
                - name: pathInRepo
                  value: stepactions/bundles/pick-cluster-version/0.1/pick-cluster-version.yaml
            params:
              - name: fbcFragment
                value: "$(tasks.parse-metadata.results.component-container-image)"
              - name: clusterVersions
                value: ["$(steps.get-supported-versions.results.versions[*])"]
          - name: pick-cluster-arch
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/asergienk/tekton-integration-catalog.git
                - name: revision
                  value: test
                - name: pathInRepo
                  value: stepactions/bundles/pick-cluster-arch/0.1/pick-cluster-arch.yaml
            params:            
              - name: bundleImage
                value: "$(tasks.get-unreleased-bundle.results.unreleasedBundle)"
    - name: provision-cluster
      runAfter:
        - pick-cluster-params
      when:
        - input: "$(tasks.get-unreleased-bundle.results.unreleasedBundle)"
          operator: notin
          values: [""]
        - input: "$(tasks.pick-cluster-params.results.ocpVersion)"
          operator: notin
          values: [""]
        - input: "$(tasks.pick-cluster-params.results.bundleArch)"
          operator: notin
          values: [""]
      taskSpec:
        results:
          - name: clusterName
            value: "$(steps.create-cluster.results.clusterName)"
        steps:
          - name: get-latest-version-tag
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/build-definitions.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/eaas-get-latest-openshift-version-by-prefix/0.1/eaas-get-latest-openshift-version-by-prefix.yaml
            params:
              - name: prefix
                value: "$(tasks.pick-cluster-params.results.ocpVersion)"
          - name: create-cluster
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/build-definitions.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/eaas-create-ephemeral-cluster-hypershift-aws/0.1/eaas-create-ephemeral-cluster-hypershift-aws.yaml
            params:
              - name: eaasSpaceSecretRef
                value: $(tasks.provision-eaas-space.results.secretRef)
              - name: version
                value: "$(steps.get-latest-version-tag.results.version)"
              - name: instanceType
                value: "m5.large"
    - name: deploy-operator
      runAfter:
        - provision-cluster
      when:
        - input: "$(tasks.get-unreleased-bundle.results.unreleasedBundle)"
          operator: notin
          values: [""]
      params:
        - name: eaasSpaceSecretRef
          value: $(tasks.provision-eaas-space.results.secretRef)
        - name: clusterName
          value: "$(tasks.provision-cluster.results.clusterName)"
        - name: fbcFragment
          value: "$(tasks.parse-metadata.results.component-container-image)"
        - name: bundleImage
          value: "$(tasks.get-unreleased-bundle.results.unreleasedBundle)"
        - name: packageName
          value: "$(tasks.get-unreleased-bundle.results.packageName)"
        - name: channelName
          value: "$(tasks.get-unreleased-bundle.results.channelName)"
      taskSpec:
        params:
          - name: eaasSpaceSecretRef
            type: string
          - name: clusterName
            type: string
          - name: fbcFragment
            type: string
          - name: bundleImage
            type: string
          - name: packageName
            type: string
          - name: channelName
            type: string
        volumes:
          - name: credentials
            emptyDir: {}
          - name: oci-auth
            secret:
              secretName: $(params.CREDENTIALS_SECRET_NAME)
        steps:
          - name: get-kubeconfig
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/build-definitions.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/eaas-get-ephemeral-cluster-credentials/0.1/eaas-get-ephemeral-cluster-credentials.yaml
            params:
              - name: eaasSpaceSecretRef
                value: $(params.eaasSpaceSecretRef)
              - name: clusterName
                value: $(params.clusterName)
              - name: credentials
                value: credentials
          - name: install-operator
            # In case the test fails, we don't want to fail the TaskRun immediately,
            # because we want to proceed with archiving the artifacts in a following step.
            onError: continue
            image: quay.io/konflux-ci/konflux-test:v1.4.24@sha256:47473fad67b5a5f4c3a701846ebcb0f732344b72aa12ad693d2313319b18930a
            computeResources:
              limits:
                memory: 4Gi
              requests:
                memory: 4Gi
                cpu: 500m
            env:
              - name: FBC_FRAGMENT
                value: "$(params.fbcFragment)"
              - name: BUNDLE_IMAGE
                value: "$(params.bundleImage)"
              - name: PACKAGE_NAME
                value: "$(params.packageName)"
              - name: CHANNEL_NAME
                value: "$(params.channelName)"
              - name: KUBECONFIG
                value: "/credentials/$(steps.get-kubeconfig.results.kubeconfig)"
            volumeMounts:
              - name: credentials
                mountPath: /credentials
            script: |
              #!/usr/bin/env bash
              set -euo pipefail
              . /utils.sh

              echo "[INFO] Using kubeconfig at $KUBECONFIG"
              oc whoami || { echo "Failed to connect to cluster"; exit 1; }

              for var in FBC_FRAGMENT BUNDLE_IMAGE PACKAGE_NAME CHANNEL_NAME; do
                if [[ -z "${!var}" ]]; then
                    echo "Error: $var parameter is required." >&2
                    exit 1
                fi
              done

              BUNDLE_IMAGE=quay.io/redhat-user-workloads/service-mesh-tenant/ossm-3-0-bundle@sha256:0d5367b95d8367daa5d1c49a074b06e52966ded8fa502c3a77c8c42f75a382bc

              # Run opm render on a bundle image
              if ! bundle_render_out=$(opm render "$BUNDLE_IMAGE"); then
                echo "Failed to render the bundle image" >&2
                exit 1
              fi

              echo "[$(date --utc +%FT%T.%3NZ)] Retrieving 'operatorframework.io/suggested-namespace' metadata annotation if exists..."
              INSTALL_NAMESPACE=$(get_bundle_suggested_namespace "$bundle_render_out")

              if [[ -z "$INSTALL_NAMESPACE" || "${INSTALL_NAMESPACE}" == null ]]; then
                echo "[$(date --utc +%FT%T.%3NZ)] No suggested namespace found, creating a new one"
                NS_NAMESTANZA="generateName: oo-"
              elif ! oc get namespace "$INSTALL_NAMESPACE"; then
                echo "[$(date --utc +%FT%T.%3NZ)] Suggested namespace is '$INSTALL_NAMESPACE' which does not exist: creating"
                NS_NAMESTANZA="name: $INSTALL_NAMESPACE"
              else
                echo "[$(date --utc +%FT%T.%3NZ)] INSTALL_NAMESPACE is '$INSTALL_NAMESPACE'"
              fi

              if [[ -n "${NS_NAMESTANZA:-}" ]]; then
                INSTALL_NAMESPACE=$(
                  oc create -f - -o jsonpath='{.metadata.name}' <<EOF
              apiVersion: v1
              kind: Namespace
              metadata:
                $NS_NAMESTANZA
              EOF
                )
              fi

              echo "[$(date --utc +%FT%T.%3NZ)] Retrieving bundle install modes..."
              if ! TARGET_NAMESPACES=$(get_bundle_install_modes "$bundle_render_out"); then
                echo "Could not get target namespaces for the bundle" >&2
                exit 1
              fi

              TARGET_NAMESPACES_FINAL=""

              # Prioritize install modes in the correct order
              if echo "$TARGET_NAMESPACES" | grep -q "AllNamespaces"; then
                  echo "AllNamespaces is supported"
                  TARGET_NAMESPACES_FINAL=""
              elif echo "$TARGET_NAMESPACES" | grep -q "SingleNamespace"; then
                  echo "SingleNamespace is supported"
                  TARGET_NAMESPACES_FINAL="default"
              elif echo "$TARGET_NAMESPACES" | grep -q "OwnNamespace"; then
                  echo "OwnNamespace is supported"
                  TARGET_NAMESPACES_FINAL="$INSTALL_NAMESPACE"
              elif echo "$TARGET_NAMESPACES" | grep -q "MultiNamespace"; then
                  echo "MultiNamespace is supported"
                  TARGET_NAMESPACES_FINAL="openshift-marketplace,default"
              else
                  echo "Error: Unsupported TARGET_NAMESPACES value: $TARGET_NAMESPACES" >&2
                  exit 1
              fi

              TARGET_NAMESPACES="$TARGET_NAMESPACES_FINAL"

              OPERATORGROUP=$(oc -n "$INSTALL_NAMESPACE" get operatorgroup -o jsonpath="{.items[*].metadata.name}" || true)

              if [[ $(echo "$OPERATORGROUP" | wc -w) -gt 1 ]]; then
                  echo "[$(date --utc +%FT%T.%3NZ)] Error: multiple OperatorGroups in namespace \"$INSTALL_NAMESPACE\": $OPERATORGROUP" 1>&2
                  echo "[$(date --utc +%FT%T.%3NZ)] Script Completed Execution With Failures!"
                  exit 1
              elif [[ -n "$OPERATORGROUP" ]]; then
                  echo "[$(date --utc +%FT%T.%3NZ)] OperatorGroup \"$OPERATORGROUP\" exists: modifying it"
                  OG_OPERATION=apply
                  OG_NAMESTANZA="name: $OPERATORGROUP"
              else
                  echo "[$(date --utc +%FT%T.%3NZ)] OperatorGroup does not exist: creating it"
                  OG_OPERATION=create
                  OG_NAMESTANZA="generateName: oo-"
              fi

              OPERATORGROUP=$(
                  oc $OG_OPERATION -f - -o jsonpath='{.metadata.name}' <<EOF
              apiVersion: operators.coreos.com/v1
              kind: OperatorGroup
              metadata:
                $OG_NAMESTANZA
                namespace: $INSTALL_NAMESPACE
              spec:
                targetNamespaces: [$TARGET_NAMESPACES]
              EOF
              )

              echo "[$(date --utc +%FT%T.%3NZ)] OperatorGroup name is \"$OPERATORGROUP\""

              CS_NAMESTANZA="generateName: oo-"

              CS_MANIFEST=$(cat <<EOF
              apiVersion: operators.coreos.com/v1alpha1
              kind: CatalogSource
              metadata:
                $CS_NAMESTANZA
                namespace: $INSTALL_NAMESPACE
              spec:
                sourceType: grpc
                image: quay.io/redhat-user-workloads/service-mesh-tenant/ossm-fbc-v4-17@sha256:f32b2da1cd6b80904295c65de23c4279984d667e860eb1faf0b951103cfc69d9
                grpcPodConfig:
                  securityContextConfig: restricted
                  extractContent:
                    catalogDir: /configs
                    cacheDir: /tmp/cache
              EOF
              )

              echo "[$(date --utc +%FT%T.%3NZ)] Creating CatalogSource:"
              echo "$CS_MANIFEST"
              CATSRC=$(oc create -f - -o jsonpath='{.metadata.name}' <<< "${CS_MANIFEST}" )
              echo "[$(date --utc +%FT%T.%3NZ)] CatalogSource name is \"$CATSRC\""

              # Waits up to 10 minutes until the Catalog source state is 'READY'
              IS_CATSRC_CREATED=false
              for i in $(seq 1 60); do
                CATSRC_STATE=$(oc get catalogsources/"$CATSRC" -n "$INSTALL_NAMESPACE" -o jsonpath='{.status.connectionState.lastObservedState}')
                echo $CATSRC_STATE
                if [ "$CATSRC_STATE" = "READY" ]; then
                  echo "[$(date --utc +%FT%T.%3NZ)] Catalogsource created successfully after waiting $((5*i)) seconds"
                  echo "[$(date --utc +%FT%T.%3NZ)] Current state of catalogsource is \"$CATSRC_STATE\""
                  IS_CATSRC_CREATED=true
                  break
                fi
                sleep 5
              done

              if [ $IS_CATSRC_CREATED = false ]; then
                echo "[$(date --utc +%FT%T.%3NZ)] Timed out waiting for the catalog source $CATSRC to become ready after 10 minutes."
                echo "[$(date --utc +%FT%T.%3NZ)] Catalogsource state at timeout is \"$CATSRC_STATE\""
                echo "[$(date --utc +%FT%T.%3NZ)] Script Completed Execution With Failures!"
                exit 1
              fi

              echo "[$(date --utc +%FT%T.%3NZ)] Set the deployment start time"

              SUB_NAMESTANZA="generateName: oo-"

              echo "[$(date --utc +%FT%T.%3NZ)] Getting bundle name from image"
              if ! bundleName=$(get_bundle_name "$bundle_render_out"); then
                echo "Could not get a bundle name from a given image" >&2
                exit 1
              fi

              SUB_MANIFEST=$(cat <<EOF
              apiVersion: operators.coreos.com/v1alpha1
              kind: Subscription
              metadata:
                $SUB_NAMESTANZA
                namespace: $INSTALL_NAMESPACE
              spec:
                name: $PACKAGE_NAME
                channel: $CHANNEL_NAME
                source: $CATSRC
                sourceNamespace: $INSTALL_NAMESPACE
                installPlanApproval: Manual
                startingCSV: $bundleName
              EOF
              )

              echo "[$(date --utc +%FT%T.%3NZ)] Creating Subscription:"
              echo "${SUB_MANIFEST}"

              SUB=$(oc create -f - -o jsonpath='{.metadata.name}' <<< "${SUB_MANIFEST}" )

              echo "[$(date --utc +%FT%T.%3NZ)] Subscription name is \"$SUB\""

              echo "[$(date --utc +%FT%T.%3NZ)] Waiting up to 5 minutes for installPlan to be created"
              FOUND_INSTALLPLAN=false
              for _ in $(seq 1 60); do
                INSTALL_PLAN=$(oc -n "$INSTALL_NAMESPACE" get subscription "$SUB" -o jsonpath='{.status.installplan.name}' || true)

                if [[ -n "$INSTALL_PLAN" ]]; then
                  oc -n "$INSTALL_NAMESPACE" patch installPlan "${INSTALL_PLAN}" --type merge --patch '{"spec":{"approved":true}}'
                  FOUND_INSTALLPLAN=true
                  break
                fi
                sleep 5
              done

              if [ "$FOUND_INSTALLPLAN" = true ]; then
                echo "[$(date --utc +%FT%T.%3NZ)] Install Plan approved"
                echo "[$(date --utc +%FT%T.%3NZ)] Waiting up to 10 minutes for ClusterServiceVersion to become ready..."
                
                for _ in $(seq 1 60); do
                  CSV=$(oc -n "$INSTALL_NAMESPACE" get subscription "$SUB" -o jsonpath="{.status.installedCSV}" || true)
                  if [[ -n "$CSV" ]]; then
                    if [[ "$(oc -n "$INSTALL_NAMESPACE" get csv "$CSV" -o jsonpath='{.status.phase}')" == "Succeeded" ]]; then
                      echo "[$(date --utc +%FT%T.%3NZ)] ClusterServiceVersion \"$CSV\" ready"
                      echo "[$(date --utc +%FT%T.%3NZ)] Script Completed Execution Successfully !"
                      exit 0
                    fi
                  fi
                  sleep 10
                done

                echo "[$(date --utc +%FT%T.%3NZ)] Timed out waiting for CSV to become ready"
                exit 1
              else
                echo "[$(date --utc +%FT%T.%3NZ)] Failed to find installPlan for subscription"
                exit 1
              fi
          - name: gather-cluster-resources
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/tekton-integration-catalog
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/gather-cluster-resources/0.1/gather-cluster-resources.yaml
            params:
              - name: credentials
                value: "credentials"
              - name: kubeconfig
                value: "$(steps.get-kubeconfig.results.kubeconfig)"
              - name: artifact-dir
                value: "/workspace/konflux-artifacts"
          # validate that the cluster resources are available in another tekton step
          - name: list-artifacts
            image: quay.io/konflux-ci/konflux-test:v1.4.21@sha256:ddce6bc954694b55808507c1f92dfe9d094d52c636c8154c3fee441faff19f90
            workingDir: "/workspace"
            script: |
              #!/bin/bash
              ls -la /workspace
          - name: push-artifacts
            ref: 
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/tekton-integration-catalog.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/secure-push-oci/0.1/secure-push-oci.yaml
            params:
              - name: workdir-path
                value: /workspace
              - name: oci-ref
                value: $(params.OCI_REF):$(tasks.parse-metadata.results.source-git-revision)
              - name: credentials-volume-name
                value: oci-auth
          - name: fail-if-any-step-failed
            ref:
              resolver: git
              params:
                - name: url
                  value: https://github.com/konflux-ci/tekton-integration-catalog.git
                - name: revision
                  value: main
                - name: pathInRepo
                  value: stepactions/fail-if-any-step-failed/0.1/fail-if-any-step-failed.yaml
